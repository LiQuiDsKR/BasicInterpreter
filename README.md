# Basic Interpreter 코드 분석 과제

## 시작에 앞서

해당 보고서는 C 언어로 작성된 “Basic Interpreter”의 전체 구조와 동작 원리를 기술적으로 분석하기 위한 문서입니다.

해당 보고서를 작성하기 위해 원고 작성을 완료한 뒤, ChatGPT 등의 LLM을 활용하여 오류 수정, 내용 첨삭 및 Markdown 문법을 적용하여 작성되었음을 알립니다.

프로그램의 실행 흐름, 자료구조 설계, 주요 함수의 역할, 후위표기법 계산 과정, 그리고 함수 호출 처리 방식에 대해 상세히 다룹니다.

과제 수행을 위해 제공된 basic_interpreter.c 소스코드를 아래 내용과 같이 분석했습니다.

---

## 프로그램 수행 절차 분석

### 1. 전체 실행 흐름

```
[소스 파일 입력] 
    ↓
[라인 단위 파싱]
    ↓
[구문 분석: 변수 / 함수 / 수식 / 블록]
    ↓
[스택에 노드(Node) 푸시]
    ↓
[수식 처리 시 후위표기 변환 및 계산]
    ↓
[함수 호출 시 스택 기반 점프 처리]
    ↓
[출력: 최종 결과 표시]
```

- 프로그램은 `.spl` 확장자를 가진 텍스트 파일을 인자로 입력받아 실행됩니다.  
- 각 줄을 순차적으로 읽어 들이며, 구문에 따라 Stack에 `Node`를 저장합니다.  
- 괄호로 감싸진 수식은 후위표기(postfix)로 변환된 뒤 계산됩니다.  
- `function`, `begin`, `end` 등의 키워드가 등장하면 실행 블록을 구성합니다.  
- `end`를 만나면 함수 호출이 종료되고 결과를 상위 호출로 반환합니다.

---

### 2. 주요 처리 절차 요약

| 단계 | 처리 내용 | 관련 구조체 / 함수 |
|------|------------|----------------------|
| 파일 입력 | 입력 파일 열기, 라인 단위로 읽기 | `fgets()`, `rstrip()` |
| 구문 분석 | `int`, `function`, `begin`, `end` 구분 | `my_stricmp()`, `Push()` |
| 변수 선언 | `Node(type=1)` 생성, 변수명·값 저장 | `Push()` |
| 함수 정의 | `Node(type=2)` 저장, 라인 번호 기록 | `Push()` |
| 수식 처리 | 중위표기 → 후위표기 변환, 스택 계산 | `PushOp()`, `PopOp()`, `PushPostfix()` |
| 함수 호출 | 호출 노드 추가 및 파일 재탐색 | `GetVal()`, `GetLastFunctionCall()` |
| 메모리 정리 | 실행 종료 시 모든 노드 해제 | `FreeAll()` |

---

## 주요 구조체 및 함수 역할

### 1. 자료구조 개요

| 구조체 | 역할 |
|--------|------|
| `Node` | 변수·함수·함수호출·블록 정보를 저장하는 기본 단위 |
| `Stack` | Node를 연결하는 일반 스택 |
| `OpStack` | Operator Stack, 연산자(`+ - * /`) 전용 스택 |
| `PostfixStack` | 후위표기 계산 시 피연산자 저장 스택 |

#### Node 구조체
```c
struct node {
    int type;        // 1: 변수, 2: 함수, 3: 함수호출, 4: begin, 5: end
    char exp_data;   // 변수명/함수명 (1문자 제한)
    int val;         // 값
    int line;        // 정의된 소스코드 라인
    struct node* next;
};
```

#### Stack 구조
- 연결리스트 기반 스택.
- `Push()`로 삽입, `Pop()`으로 제거.
- 후입선출(LIFO) 구조를 유지하여 블록 및 함수 호출 제어에 적합.

---

### 2. 주요 함수 역할

| 함수명 | 설명 |
|--------|------|
| `Push()` | Node를 스택의 top에 삽입 |
| `Pop()` | 스택에서 Node를 제거하고 반환 |
| `PushOp()` / `PopOp()` | 연산자 스택 관리 (`+ - * /`) |
| `PushPostfix()` / `PopPostfix()` | 후위표기 계산용 피연산자 스택 관리 |
| `Priotry()` | 연산자 우선순위 반환 |
| `GetVal()` | 스택에서 변수·함수명을 검색하여 값 또는 라인 반환 |
| `GetLastFunctionCall()` | 마지막 함수 호출 라인 번호 탐색 |
| `FreeAll()` | 모든 Node 메모리 해제 |
| `rstrip()` | 개행 문자 제거 |
| `my_stricmp()` | 대소문자 구분 없는 문자열 비교 |

---

## 코드 동작 원리

### 1. main()의 전체 흐름

1. 초기화
   - 3종 스택(`Stack`, `OpStack`, `PostfixStack`)을 동적 할당 후 초기화.
   - 콘솔을 지우고 입력 인자 확인 (`argc != 2` 시 종료).

2. 파일 열기
   - `fopen(argv[1], "r")`로 파일 오픈.
   - 실패 시 에러 메시지 출력 후 종료.

3. 라인 단위 읽기 (`while fgets`)
   - 탭 → 공백 변환, 개행 제거 (`rstrip`).
   - 각 줄의 첫 단어(`int`, `function`, `begin`, `end`, `(` 등)를 구분.

4. 문법별 처리
   - `int a = 3` → 변수 노드(`type=1`) 생성, 스택에 푸시.
   - `function main` → 함수 노드(`type=2`) 생성, 실행 진입점으로 설정.
   - `begin` / `end` → 블록 시작/종료 제어용 노드 추가.
   - `(a + b * 2)` → 수식 계산 절차로 이동.

5. 함수 호출 처리
   - `GetVal()`로 함수 위치(line) 조회 후, 파일 포인터를 그 위치로 되감음.
   - 실행이 끝나면 호출 스택에서 `type=3` 노드를 제거.

6. 수식 계산
   - 중위식을 후위표기법으로 변환 후 계산.

7. 프로그램 종료
   - 파일 닫기 → 스택 메모리 해제 → 최종 결과 출력.

---

## 후위표기 수식 계산 과정

### 1. 중위 → 후위 변환 알고리즘

```c
while (문자열 탐색) {
    if (숫자) postfix에 추가;
    if (연산자) {
        while (스택 top의 우선순위 >= 현재 연산자)
            pop 후 postfix에 추가;
        push 현재 연산자;
    }
    if (')') 스택에서 연산자 pop;
}
```

예시  
입력: `( 3 + 4 * 2 )`  
변환: `3 4 2 * +`  
계산: `3 + (4*2) = 11`

### 2. 후위표기 계산

```c
for (각 문자 in postfix) {
    if (숫자) → 피연산자 스택에 push;
    if (연산자) {
        val1 = pop();
        val2 = pop();
        결과 = val2 op val1;
        push(결과);
    }
}
```

최종적으로 `CalcStack->top->val`에 결과가 저장되고,  
이 값이 `LastExpReturn`으로 반환되어 프로그램 출력으로 이어진다.

---

## 함수 호출 시뮬레이션

### 1. GetVal()의 역할
- 전달된 문자가 변수인지 함수인지 판단.
- 변수(type=1) → `val` 반환.  
- 함수(type=2) → `line`에 정의 위치 저장 후 `-1` 반환.

### 2. 함수 호출 시나리오
```basic
function main
begin
int a = 5
( square(a) )
end

function square x
begin
( x * x )
end
```

실행 과정:
1. main 시작 → `a=5` 등록.  
2. `square(a)` 호출 발견 → `GetVal('s')` → 함수 line 위치 확인.  
3. 파일 재탐색 → `function square` 라인부터 실행.  
4. 인자 전달 (`x=5`) → `(x*x)` 계산 후 결과 25.  
5. `LastFunctionReturn = 25` → 상위 호출로 복귀.

---

## 코드 평가 및 개선 제안

| 구분 | 내용 |
|------|------|
| 장점 | 구조 단순, 스택 기반 로직 명확, 인터프리터 원리 학습용으로 적합 |
| 단점 | 단일 문자 변수명 한정, 함수 인자 1개만 지원, 중첩괄호 처리 미흡, 예외 처리 부족 |
| 개선 제안 |<ul><li>`exp_data`를 문자열 배열로 확장 (변수/함수명 문자열 지원)</li><li>괄호 중첩 처리 스택 개선</li><li>`foundMain`에 대한 예외처리 부족</li></li><li>실수 자료형 구현</li> |

---

## 결과 요약

- 본 프로그램은 스택 기반의 간단한 BASIC 해석기(interpreter)로,  
  각 구문을 `Node` 구조로 저장하고 후위표기 수식을 계산하여 결과를 산출한다.  
- 함수 호출·블록 제어·산술 연산 처리가 모두 포함된 소규모 인터프리터의 형태를 갖춘다.  
- 스택의 사용 구조, 후위표기 변환 알고리즘, 그리고 `GetVal()`의 호출–복귀 설계는  
  운영체제와 언어 처리기(compiler/interpreter) 학습의 좋은 기초 예제이다.